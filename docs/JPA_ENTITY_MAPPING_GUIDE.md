# JPA Entity Mapping Guide for Story 3.3

## Overview

This document prepares for Story 3.3 (Implement JPA Entity and Repository) by documenting the expected entity mapping based on the current database schema created by Liquibase migrations.

## Database Schema (Current State)

Based on Liquibase changelog (`db.changelog-master.yaml`), the database has the following structure:

### Table: `urls`

| Column | Type | Constraints | Default |
|--------|------|-------------|---------|
| `short_code` | VARCHAR(10) | PRIMARY KEY, NOT NULL | - |
| `original_url` | TEXT | NOT NULL | - |
| `created_at` | TIMESTAMP | NOT NULL | CURRENT_TIMESTAMP |

### Indexes

1. **Primary Key Index** (automatic): `short_code`
2. **Unique Index**: `idx_original_url_normalized` on `original_url`
   - Note: Changed in changeset 004 from expression-based to simple unique index
   - Application must normalize URLs before database operations

## Expected JPA Entity Mapping

### Entity Class: `UrlEntity`

**File:** `src/main/java/com/example/urlshortener/entity/UrlEntity.java`

```java
package com.example.urlshortener.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Table(name = "urls", indexes = {
    @Index(name = "idx_original_url_normalized", columnList = "original_url", unique = true)
})
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UrlEntity {
    
    @Id
    @Column(name = "short_code", nullable = false, length = 10)
    private String shortCode;
    
    @Column(name = "original_url", nullable = false, columnDefinition = "TEXT")
    private String originalUrl;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
    }
}
```

### Key Mapping Decisions

1. **Primary Key (`short_code`)**
   - Type: `String` (not auto-generated)
   - Generated by `SnowflakeIdGenerator` and Base62-encoded
   - No `@GeneratedValue` - application controls ID generation

2. **URL Field (`original_url`)**
   - Type: `String` (TEXT in DB)
   - **CRITICAL**: Must be normalized BEFORE saving to database
   - Service layer responsible for normalization: `url.toLowerCase().trim()`

3. **Timestamp Field (`created_at`)**
   - Type: `LocalDateTime` (maps to TIMESTAMP)
   - `@PrePersist` ensures value is set if null
   - `updatable = false` prevents modifications after creation

4. **Unique Constraint**
   - Defined at table level: `@Index` with `unique = true`
   - Enforces uniqueness on `original_url` (pre-normalized)

## Expected Repository Interface

### Repository: `UrlRepository`

**File:** `src/main/java/com/example/urlshortener/repository/UrlRepository.java`

```java
package com.example.urlshortener.repository;

import com.example.urlshortener.entity.UrlEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UrlRepository extends JpaRepository<UrlEntity, String> {
    
    /**
     * Find URL mapping by normalized original URL.
     * 
     * IMPORTANT: Caller MUST normalize the URL before calling this method:
     *   String normalizedUrl = url.toLowerCase().trim();
     * 
     * @param originalUrl the NORMALIZED original URL
     * @return Optional containing UrlEntity if found
     */
    Optional<UrlEntity> findByOriginalUrl(String originalUrl);
    
    /**
     * Check if a normalized URL already exists.
     * 
     * IMPORTANT: Caller MUST normalize the URL before calling this method.
     * 
     * @param originalUrl the NORMALIZED original URL
     * @return true if URL exists
     */
    boolean existsByOriginalUrl(String originalUrl);
}
```

### Key Repository Decisions

1. **Generic Type Parameters**
   - `JpaRepository<UrlEntity, String>` (entity type, ID type)
   - ID type is `String` (short_code column)

2. **Custom Query Methods**
   - `findByOriginalUrl`: Find by normalized URL (for idempotency)
   - `existsByOriginalUrl`: Check existence (optimization for duplicate checks)
   - No custom `@Query` needed - Spring Data JPA auto-generates

3. **Method Naming Convention**
   - Spring Data JPA derives queries from method names
   - `findBy...`, `existsBy...` patterns

## Application-Level Normalization Requirement

**CRITICAL for Story 3.3 and Story 2.5**

### Why Normalization is Required

Changeset 004 removed database-side normalization (expression-based index) in favor of application-side normalization. This means:

1. **Service Layer Responsibility**
   - Service must normalize URLs before ANY database operation
   - Pattern: `String normalized = url.toLowerCase().trim()`

2. **Where to Normalize**
   - Before insert: Normalize before creating `UrlEntity`
   - Before query: Normalize before calling `findByOriginalUrl`
   - Before idempotency check: Normalize before calling `existsByOriginalUrl`

### Normalization Implementation

**Helper Method in Service:**
```java
private String normalizeUrl(String url) {
    if (url == null) {
        throw new IllegalArgumentException("URL cannot be null");
    }
    return url.toLowerCase().trim();
}
```

**Usage Examples:**
```java
// Creating new URL mapping
String normalizedUrl = normalizeUrl(request.getUrl());
UrlEntity entity = new UrlEntity(shortCode, normalizedUrl, null);
repository.save(entity);

// Finding existing URL
String normalizedUrl = normalizeUrl(url);
Optional<UrlEntity> existing = repository.findByOriginalUrl(normalizedUrl);
```

### Why This Matters

1. **Idempotency (Story 2.5)**
   - Same URL (case-insensitive) returns same short code
   - Relies on unique index on normalized URLs

2. **Data Integrity**
   - Prevents duplicates: "https://EXAMPLE.COM" vs "https://example.com"
   - Database enforces uniqueness on pre-normalized values

3. **Query Consistency**
   - All queries use normalized URLs
   - No complex SQL expressions needed

## Spring JPA Configuration

### Expected `application.yml` Settings

```yaml
spring:
  jpa:
    hibernate:
      ddl-auto: validate  # IMPORTANT: Liquibase controls schema, Hibernate only validates
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
```

### Why `ddl-auto: validate`?

- **Liquibase controls schema**: All DDL changes via Liquibase changesets
- **Hibernate validates**: Ensures entity mapping matches database schema
- **Fail-fast**: Application won't start if entity doesn't match schema
- **Production-safe**: No accidental schema changes by Hibernate

### Validation Behavior

When application starts:
1. Liquibase applies migrations (if any pending)
2. Hibernate validates entity mapping against database
3. If mismatch: Application fails to start (shows mapping error)
4. If match: Application starts successfully

## Schema/Entity Mapping Gotchas

### 1. Column Name Mapping

**Database:** Uses snake_case (`short_code`, `original_url`, `created_at`)  
**Java:** Uses camelCase (`shortCode`, `originalUrl`, `createdAt`)

**Solution:** Explicitly map with `@Column(name = "...")`

### 2. TEXT vs String

**Database:** `original_url` is `TEXT` (unlimited length)  
**JPA:** Maps to `String` by default (VARCHAR 255)

**Solution:** Use `columnDefinition = "TEXT"` in `@Column`

### 3. Timestamp Default Value

**Database:** `created_at` has `DEFAULT CURRENT_TIMESTAMP`  
**JPA:** Won't use database default by default

**Solution:** Use `@PrePersist` to set value before insert

### 4. Unique Index

**Database:** Unique index on `original_url`  
**JPA:** Not automatically enforced

**Solution:** Define at `@Table` level with `@Index(unique = true)`

### 5. ID Generation

**Database:** No auto-increment (application-generated ID)  
**JPA:** Expects `@GeneratedValue` for auto IDs

**Solution:** Don't use `@GeneratedValue` - set ID manually from SnowflakeIdGenerator

## Testing Checklist for Story 3.3

When implementing JPA entity/repository:

- [ ] Entity compiles without errors
- [ ] Application starts with `ddl-auto: validate`
- [ ] No schema validation errors in logs
- [ ] `UrlRepository` can save new entities
- [ ] `findById` retrieves by short_code
- [ ] `findByOriginalUrl` retrieves by normalized URL
- [ ] Unique constraint violation when inserting duplicate normalized URL
- [ ] `created_at` is auto-populated on insert
- [ ] Integration tests pass with Testcontainers

## Integration with Existing Code

### Story 2.4: SnowflakeIdGenerator

**Already exists:** `SnowflakeIdGenerator` component

**Integration:**
```java
@Autowired
private SnowflakeIdGenerator generator;

@Autowired
private Base62Encoder encoder;

String shortCode = encoder.encode(generator.nextId());
```

### Story 2.5: Database-Enforced Idempotency

**Depends on Story 3.3**

**Implementation Pattern:**
```java
public ShortenResponse shorten(ShortenRequest request) {
    String normalizedUrl = normalizeUrl(request.getUrl());
    
    // Try to find existing
    Optional<UrlEntity> existing = repository.findByOriginalUrl(normalizedUrl);
    if (existing.isPresent()) {
        return new ShortenResponse(existing.get().getShortCode(), /* ... */);
    }
    
    // Generate new short code
    String shortCode = encoder.encode(generator.nextId());
    
    // Try to insert
    try {
        UrlEntity entity = new UrlEntity(shortCode, normalizedUrl, null);
        repository.save(entity);
        return new ShortenResponse(shortCode, /* ... */);
    } catch (DataIntegrityViolationException e) {
        // Rare race condition: Another thread inserted same URL
        // Retry: Fetch the URL that was just inserted
        UrlEntity raceConditionEntity = repository.findByOriginalUrl(normalizedUrl)
            .orElseThrow(() -> new IllegalStateException("Unexpected state"));
        return new ShortenResponse(raceConditionEntity.getShortCode(), /* ... */);
    }
}
```

## Next Steps

1. **Story 3.3:** Implement `UrlEntity` and `UrlRepository`
   - Use this document as implementation guide
   - Follow JPA best practices
   - Test with Testcontainers

2. **Story 3.4:** Configure Spring Data JPA and PostgreSQL Connection
   - Verify `application.yml` configuration
   - Test connection pooling
   - Configure environment-specific profiles

3. **Story 2.5:** Implement Database-Enforced Idempotency
   - Replace `UrlShortenerServiceStub` with JPA-backed implementation
   - Use try-insert-catch-select pattern
   - Handle `DataIntegrityViolationException`

## References

- Current Liquibase Changelog: `src/main/resources/db/changelog/db.changelog-master.yaml`
- Migration Guide: `docs/LIQUIBASE_MIGRATION_GUIDE.md`
- Database Schema Design: `docs/DATABASE_SCHEMA_DESIGN.md`
- Architecture Document: `_bmad-output/planning-artifacts/architecture.md`
- Spring Data JPA Documentation: https://docs.spring.io/spring-data/jpa/docs/current/reference/html/
- Hibernate Documentation: https://hibernate.org/orm/documentation/6.4/

---

**Created:** 2024-02-09  
**Story:** 3-2 Create Liquibase Migration Changelog (Task 5)  
**Purpose:** Prepare for Story 3.3 JPA Entity Implementation
